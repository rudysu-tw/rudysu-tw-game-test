<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠŸå¤«éæ‹› - æ­¦æ—å¥‡é‡ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700;900&display=swap');

        body {
            font-family: 'Noto Serif TC', serif;
            background-color: #1a1a1a;
            color: #e5e5e5;
            overflow-x: hidden;
            user-select: none;
        }

        .wuxia-border {
            border: 2px solid #d4af37;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.3), inset 0 0 20px rgba(0,0,0,0.8);
            background: rgba(30, 30, 30, 0.9);
            position: relative;
        }
        
        .wuxia-border::after {
            content: '';
            position: absolute;
            top: 2px; left: 2px; right: 2px; bottom: 2px;
            border: 1px solid rgba(212, 175, 55, 0.5);
            pointer-events: none;
        }

        .card-hover:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.6);
            border-color: #fff;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #d4af37; }

        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        .flash-hit { animation: flash-red 0.3s; }
        .flash-clash { animation: flash-white 0.3s; }
        .flash-event { animation: flash-yellow 0.5s; }
        @keyframes flash-red { 0% { background-color: rgba(255,0,0,0.5); } 100% { background-color: transparent; } }
        @keyframes flash-white { 0% { background-color: rgba(255,255,255,0.8); } 100% { background-color: transparent; } }
        @keyframes flash-yellow { 0% { background-color: rgba(255,200,0,0.4); } 50% { background-color: transparent; } 100% { background-color: rgba(255,200,0,0.4); } }


        .elem-icon {
            width: 20px; height: 20px; display: inline-flex;
            align-items: center; justify-content: center;
            border-radius: 50%; font-size: 10px; font-weight: bold;
            color: #fff; margin-right: 4px;
        }
        .elem-metal { background: #E6B800; }
        .elem-wood { background: #4CAF50; }
        .elem-water { background: #2196F3; }
        .elem-fire { background: #F44336; }
        .elem-earth { background: #795548; }

        .move-type-attack { background-color: #991b1b; } 
        .move-type-buff { background-color: #15803d; } 
        .move-type-defend { background-color: #1e40af; } 

        #battle-log p {
            margin-bottom: 4px; padding-bottom: 4px; border-bottom: 1px solid #333;
        }
    </style>
</head>
<body class="flex flex-col h-screen select-none">

    <!-- Header -->
    <header class="p-4 text-center border-b border-gray-700 bg-gray-900 relative z-10">
        <h1 class="text-3xl font-bold text-yellow-500 tracking-widest" style="text-shadow: 2px 2px 4px #000;">åŠŸå¤«éæ‹› - æ­¦æ—å¥‡é‡ç‰ˆ</h1>
        <div id="turn-indicator" class="text-sm text-gray-400 mt-1">å›åˆ: <span id="turn-count">0</span> | è¨ˆæ•¸: <span id="tick-count">0</span></div>
    </header>

    <!-- Main Game Area -->
    <main id="game-container" class="flex-1 flex flex-col md:flex-row overflow-hidden relative">
        
        <!-- Left: Player Stats -->
        <div class="w-full md:w-1/4 p-4 flex flex-col items-center bg-gradient-to-r from-gray-900 to-transparent z-10">
            <div id="player-avatar" class="w-24 h-24 rounded-full border-4 border-blue-500 bg-gray-800 flex items-center justify-center text-4xl mb-2 shadow-lg relative">
                ğŸ§‘
                <div id="player-element-badge" class="absolute -top-2 -right-2 w-8 h-8 rounded-full flex items-center justify-center text-xs border border-white"></div>
            </div>
            <h2 id="player-name" class="text-xl font-bold mb-1">ç©å®¶</h2>
            <div class="text-sm text-gray-400 mb-2" id="player-sect">é–€æ´¾: --</div>
            <div id="player-sect-feature" class="text-xs text-yellow-300 mb-2 p-1 border border-yellow-800 rounded">é–€æ´¾ç‰¹æ€§: --</div>
            
            <div class="w-full max-w-xs bg-gray-700 h-6 rounded-full overflow-hidden border border-gray-600 relative">
                <div id="player-hp-bar" class="h-full bg-green-600 transition-all duration-500" style="width: 100%;"></div>
                <span id="player-hp-text" class="absolute inset-0 flex items-center justify-center text-xs font-bold text-white shadow-black drop-shadow-md">100/100</span>
            </div>
            <div id="player-status" class="mt-2 text-xs text-red-300 min-h-[20px]"></div>
        </div>

        <!-- Center: Battle Visualizer -->
        <div class="flex-1 flex flex-col justify-start p-2 md:p-6 relative">
            
            <!-- Overlay for Start/End -->
            <div id="overlay-screen" class="absolute inset-0 bg-black/90 z-50 flex flex-col items-center justify-center text-center p-8">
                <h1 class="text-4xl md:text-6xl text-yellow-500 mb-6 font-bold">æ­¦æ—å¤§æœƒ</h1>
                <p class="text-gray-300 mb-8 max-w-lg leading-relaxed">
                    äº”å¤§é–€æ´¾ï¼Œå„æœ‰æ‰€é•·ã€‚æ‹›å¼ç³»çµ±ä»¥ 20 è¨ˆæ•¸ç‚ºä¸Šé™ã€‚<br>
                    æ‹›å¼æ­¥é©Ÿæ•¸ä»£è¡¨è“„åŠ›æ™‚é–“ï¼Œæ­¥é©Ÿå€¼è¶Šå¤§ï¼Œå¨åŠ›è¶Šå¼·ï¼Œä½†è¶Šå®¹æ˜“è¢«å…ˆæ‰‹æ‹›å¼æ“Šä¸­ã€‚<br>
                    ç¾åœ¨æ¯”æ­¦éç¨‹å°‡éš¨æ©Ÿå‡ºç¾**æ­¦æ—å¥‡é‡**ï¼Œå½±éŸ¿æˆ°å±€ã€‚
                </p>
                <button onclick="game.init()" class="px-8 py-3 bg-red-700 hover:bg-red-600 text-white text-xl font-bold rounded border-2 border-red-400 shadow-[0_0_15px_rgba(220,38,38,0.6)] transition-all">
                    é–‹å§‹æ¯”æ­¦
                </button>
            </div>

            <div id="game-over-screen" class="hidden absolute inset-0 bg-black/90 z-50 flex flex-col items-center justify-center text-center p-8">
                <h1 id="end-title" class="text-5xl text-white mb-4 font-bold">å‹è² å·²åˆ†</h1>
                <p id="end-reason" class="text-xl text-gray-300 mb-8">...</p>
                <button onclick="game.init()" class="px-6 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded border border-gray-500">
                    å†ä¾†ä¸€å±€
                </button>
            </div>

            <!-- Timeline Visualization Area -->
            <div class="w-full bg-gray-800/50 rounded-lg p-4 border border-gray-700 mb-4 flex-shrink-0 relative min-h-[180px] flex flex-col justify-center">
                
                <!-- Animation Layer -->
                <div id="battle-anim-layer" class="absolute inset-0 pointer-events-none z-20 overflow-hidden flex items-center justify-center"></div>

                <div class="mb-1 flex justify-between text-xs text-gray-500">
                    <span>0</span><span>è¨ˆæ•¸(Tick)</span><span>20</span>
                </div>

                <!-- Enemy Timeline -->
                <div class="relative h-10 w-full bg-gray-900 rounded mb-1 flex overflow-hidden border border-red-900/30" id="enemy-timeline">
                    <!-- Segments injected by JS -->
                </div>
                <div class="text-right text-xs text-red-400 mb-4 pr-2 flex justify-between items-center" id="enemy-move-detail">
                    <span id="enemy-move-type">å°æ‰‹æ‹›å¼é¡å‹: --</span>
                    <span id="enemy-move-name">å°æ‰‹æ­£åœ¨é‹æ°£...</span>
                </div>

                <!-- Indicator Line -->
                <div class="relative h-2 w-full bg-gray-800 mb-4">
                    <div id="timeline-cursor" class="absolute top-[-60px] bottom-[-60px] w-1 bg-yellow-500 shadow-[0_0_10px_#eab308] z-30 transition-all duration-75" style="left: 0%;"></div>
                </div>

                <!-- Player Timeline -->
                <div class="text-left text-xs text-blue-400 mb-1 pl-2 flex justify-between items-center" id="player-move-detail">
                    <span id="player-move-name">è«‹é¸æ“‡æ‹›å¼...</span>
                    <span id="player-move-type">æ‹›å¼é¡å‹: --</span>
                </div>
                <div class="relative h-10 w-full bg-gray-900 rounded flex overflow-hidden border border-blue-900/30" id="player-timeline">
                    <!-- Segments injected by JS -->
                </div>
            </div>

            <!-- Battle Log -->
            <div id="battle-log" class="flex-1 wuxia-border p-4 overflow-y-auto font-mono text-sm md:text-base text-gray-300 bg-black/40 max-h-[200px] md:max-h-none">
                <div class="text-center text-gray-500 italic">--- æ­¦æ—é¢¨é›²éŒ„ ---</div>
            </div>

        </div>

        <!-- Right: Enemy Stats -->
        <div class="w-full md:w-1/4 p-4 flex flex-col items-center bg-gradient-to-l from-gray-900 to-transparent z-10">
            <div id="enemy-avatar" class="w-24 h-24 rounded-full border-4 border-red-500 bg-gray-800 flex items-center justify-center text-4xl mb-2 shadow-lg relative">
                ğŸ¥·
                <div id="enemy-element-badge" class="absolute -top-2 -right-2 w-8 h-8 rounded-full flex items-center justify-center text-xs border border-white"></div>
            </div>
            <h2 id="enemy-name" class="text-xl font-bold mb-1">å°æ‰‹</h2>
            <div class="text-sm text-gray-400 mb-2" id="enemy-sect">é–€æ´¾: --</div>
            <div id="enemy-sect-feature" class="text-xs text-yellow-300 mb-2 p-1 border border-yellow-800 rounded">é–€æ´¾ç‰¹æ€§: --</div>

            <div class="w-full max-w-xs bg-gray-700 h-6 rounded-full overflow-hidden border border-gray-600 relative">
                <div id="enemy-hp-bar" class="h-full bg-red-600 transition-all duration-500" style="width: 100%;"></div>
                <span id="enemy-hp-text" class="absolute inset-0 flex items-center justify-center text-xs font-bold text-white shadow-black drop-shadow-md">100/100</span>
            </div>
            <div id="enemy-status" class="mt-2 text-xs text-red-300 min-h-[20px]"></div>
        </div>

    </main>

    <!-- Footer: Control Panel -->
    <footer id="control-panel" class="bg-gray-900 border-t border-gray-700 p-2 md:p-4 z-20">
        <div class="max-w-6xl mx-auto">
            <div id="move-selection-title" class="text-center text-yellow-500 mb-2 text-sm font-bold animate-pulse">è¼ªåˆ°ä½ å‡ºæ‹›äº†ï¼Œè«‹é¸æ“‡ä¸€å¼:</div>
            <div id="move-cards" class="grid grid-cols-2 md:grid-cols-4 gap-2 md:gap-4">
                <!-- Move Cards Generated Here -->
            </div>
        </div>
    </footer>

    <script>
        // --- Data & Constants ---
        const ELEMENTS = {
            METAL: { name: 'é‡‘', icon: 'âš”ï¸', weakness: 'FIRE', beats: 'WOOD', color: 'bg-yellow-600', textColor: 'text-yellow-600' },
            WOOD: { name: 'æœ¨', icon: 'ğŸŒ³', weakness: 'METAL', beats: 'EARTH', color: 'bg-green-600', textColor: 'text-green-600' },
            WATER: { name: 'æ°´', icon: 'ğŸ’§', weakness: 'EARTH', beats: 'FIRE', color: 'bg-blue-600', textColor: 'text-blue-600' },
            FIRE: { name: 'ç«', icon: 'ğŸ”¥', weakness: 'WATER', beats: 'METAL', color: 'bg-red-600', textColor: 'text-red-600' },
            EARTH: { name: 'åœŸ', icon: 'â›°ï¸', weakness: 'WOOD', beats: 'WATER', color: 'bg-amber-800', textColor: 'text-amber-800' }
        };

        const SECTS = [
            { id: 'shaolin', name: 'å°‘æ— (é‡‘)', element: 'METAL', feature: 'é‡‘å‰›ä¸å£ï¼šæ¯å›åˆé–‹å§‹æ™‚ï¼Œç²å¾— 3 é»è‡¨æ™‚é˜²ç¦¦ã€‚', skillPrefix: ['ç¾…æ¼¢', 'é‡‘å‰›', 'éŸ‹é™€', 'é”æ‘©', 'ä¼è™'], types: { ATTACK: 0.5, DEFEND: 0.3, BUFF: 0.2 } },
            { id: 'wudang', name: 'æ­¦ç•¶ (æ°´)', element: 'WATER', feature: 'å¤ªæ¥µåœ“è½‰ï¼šå›åˆçµæŸå¾Œï¼Œè‹¥æœ¬å›åˆæœªå—å‚·å®³ï¼Œå›å¾© 5 é»ç”Ÿå‘½ã€‚', skillPrefix: ['å¤ªæ¥µ', 'å…©å„€', 'æŸ”é›²', 'ç¶¿', 'ç„è™›'], types: { ATTACK: 0.4, DEFEND: 0.4, BUFF: 0.2 } },
            { id: 'emei', name: 'å³¨åµ‹ (ç«)', element: 'FIRE', feature: 'çƒˆç«ç‡åŸï¼šæˆåŠŸç™¼å‹•æ”»æ“Šæ™‚æœ‰ 20% æ©Ÿç‡è®“å°æ–¹ç²å¾—ã€Œç‡ƒç‡’ã€Debuff (æ¯å›åˆæŒçºŒæ‰£ 5 HP)ã€‚', skillPrefix: ['é£„é›ª', 'æˆªæ‰‹', 'ä½›å…‰', 'é‡‘é ‚', 'å››è±¡'], types: { ATTACK: 0.6, DEFEND: 0.2, BUFF: 0.2 } },
            { id: 'beggar', name: 'ä¸å¹« (åœŸ)', element: 'EARTH', feature: 'åŒ–éšªç‚ºå¤·ï¼šç•¶ç”Ÿå‘½å€¼ä½æ–¼ 30% æ™‚ï¼Œæ‰€æœ‰æ‹›å¼å¨åŠ›æå‡ 25%ã€‚', skillPrefix: ['é™é¾', 'æ‰“ç‹—', 'é€é™', 'æ··å…ƒ', 'è“®èŠ±'], types: { ATTACK: 0.5, DEFEND: 0.3, BUFF: 0.2 } },
            { id: 'huashan', name: 'è¯å±± (æœ¨)', element: 'WOOD', feature: 'åŠèµ°åé‹’ï¼šç™¼å‹•å°æ­¥é©Ÿ(3-5 ticks)æ”»æ“Šæ™‚ï¼Œæœ‰ 30% æ©Ÿç‡é€ æˆçˆ†æ“Š (+50% å‚·å®³)ã€‚', skillPrefix: ['ç¨å­¤', 'ç´«éœ', 'ç‹‚é¢¨', 'é¤Šå¾', 'å¥ªå‘½'], types: { ATTACK: 0.6, DEFEND: 0.2, BUFF: 0.2 } }
        ];
        
        const SKILL_SUFFIXES = ['æ‰‹', 'æŒ', 'æŒ‡', 'åŠ', 'åˆ€', 'æ‹³', 'è…¿', 'æ³•', 'å¼', 'è¨£'];


        const MOVE_TYPES = {
            ATTACK: { name: 'æ”»æ“Š', desc: 'ä¸»è¦é€ æˆå‚·å®³', style: 'move-type-attack', stepsMin: 2, stepsMax: 6, stepMaxVal: 9, basePower: 1.5 },
            DEFEND: { name: 'é˜²ç¦¦', desc: 'æå‡é˜²ç¦¦åŠ›ï¼Œæ­¥é©Ÿå€¼è¶Šé«˜é˜²ç¦¦åŠ æˆè¶Šå¤š', style: 'move-type-defend', stepsMin: 2, stepsMax: 4, stepMaxVal: 12, basePower: 0.5 },
            BUFF: { name: 'å¢ç›Š', desc: 'çµ¦è‡ªå·±å¢åŠ  Buff æˆ–è§£é™¤ Debuff', style: 'move-type-buff', stepsMin: 1, stepsMax: 3, stepMaxVal: 19, basePower: 0 }
        };

        // --- 2. éš¨æ©Ÿäº‹ä»¶å®šç¾© (å…± 21 ç¨®) ---
        const EVENTS = [
            // Positive Events (Heal/Buff)
            { name: 'ä»™é¶´å¼•å°', type: 'heal', magnitude: 10, target: 'self', log: 'ğŸ§˜ å¥‡é‡ä»™é¶´å¼•å°ï¼Œéˆæ°£çŒé«”ï¼Œå›å¾© {mag} é»å…§å‚·ã€‚' },
            { name: 'ä¸¹è—¥ä¹‹åŠ›', type: 'heal', magnitude: 15, target: 'self', log: 'ğŸ’Š æœç”¨éš¨èº«æ”œå¸¶çš„éˆä¸¹ï¼Œæ°£è¡€ç¬é–“å›å¾© {mag} é»ã€‚' },
            { name: 'é¾è™å˜¯', type: 'atk_boost', magnitude: 1.5, duration: 1, target: 'self', log: 'ğŸ… çªç™¼é¾è™å˜¯ä¹‹æ°£å‹¢ï¼Œä¸‹ä¸€æ“Šæ”»æ“ŠåŠ›æš´æ¼² 50%ï¼' },
            { name: 'éŠ…çš®éµéª¨', type: 'def_boost', magnitude: 8, duration: 1, target: 'self', log: 'ğŸ›¡ï¸ å…§åŠ›è­·é«”ï¼Œé‡‘é˜ç½©ç¾å½¢ï¼Œä¸‹ä¸€æ“Šé˜²ç¦¦åŠ›è‡¨æ™‚å¢åŠ  {mag} é»ã€‚' },
            { name: 'é¢¨åŠ©ç«å‹¢', type: 'atk_boost', magnitude: 1.3, duration: 2, target: 'self', element: 'FIRE', log: 'ğŸŒ¬ï¸ é¢¨åŠ©ç«å‹¢ï¼ç«å±¬æ€§æ‹›å¼åœ¨æ¥ä¸‹ä¾†çš„å›åˆå¨åŠ›å¢åŠ  30%ã€‚' },
            { name: 'ç¶“è„ˆèˆ’æš¢', type: 'heal', magnitude: 8, target: 'all', log: 'âœ¨ å¿½æ„Ÿç¶“è„ˆèˆ’æš¢ï¼Œé›™æ–¹çš†å›å¾© {mag} é»æ°£åŠ›ã€‚' },
            { name: 'å¤©é™ç•°å¯¶', type: 'heal', magnitude: 20, target: 'self', log: 'ğŸ’ å¤©é™ç•°å¯¶ï¼Œå¸æ”¶å…¶éˆæ°£ï¼Œå›å¾© {mag} é»ç”Ÿå‘½ï¼' },
            // Negative Events (Damage/Debuff)
            { name: 'èµ°ç«å…¥é­”', type: 'dmg', magnitude: 12, target: 'self', log: 'ğŸ’¥ å…§åŠ›é€†è¡Œï¼Œèµ°ç«å…¥é­”ï¼Œè‡ªæ {mag} é»ç²¾å…ƒï¼' },
            { name: 'è¸ç©ºå¤±ä½', type: 'def_debuff', magnitude: 5, duration: 1, target: 'self', log: 'â¬‡ï¸ è…³ä¸‹è¸ç©ºï¼Œèº«å½¢ä¸ç©©ï¼Œä¸‹ä¸€æ“Šé˜²ç¦¦åŠ›è‡¨æ™‚é™ä½ {mag} é»ã€‚' },
            { name: 'æ¯’ç˜´ä¾µè¥²', type: 'dmg', magnitude: 8, target: 'all', log: 'ğŸ’€ æ¯’ç˜´çªç¾ï¼é›™æ–¹çš†å—ä¾µè¥²ï¼Œå„æå¤± {mag} é»ç”Ÿå‘½ï¼' },
            { name: 'ç‹‚é¢¨å‘¼å˜¯', type: 'atk_debuff', magnitude: 0.7, duration: 1, target: 'other', log: 'ğŸŒªï¸ ç‹‚é¢¨å‘¼å˜¯ï¼å°æ‰‹å‡ºæ‹›å—é˜»ï¼Œä¸‹ä¸€æ“Šæ”»æ“ŠåŠ›è‡¨æ™‚é™ä½ 30%ã€‚' },
            { name: 'åœ°å‹•å±±æ–', type: 'def_debuff', magnitude: 10, duration: 1, target: 'other', log: 'â›°ï¸ åœ°å‹•å±±æ–ï¼å°æ‰‹é˜²å®ˆç”¢ç”Ÿç ´ç¶»ï¼Œä¸‹ä¸€æ“Šé˜²ç¦¦åŠ›è‡¨æ™‚é™ä½ {mag} é»ã€‚' },
            { name: 'å™¨æ¢°å—æ', type: 'atk_debuff', magnitude: 0.6, duration: 1, target: 'self', log: 'âš”ï¸ å…µå™¨å—æï¼Œä¸‹ä¸€æ“Šæ”»æ“ŠåŠ›å¤§æ¸› 40%ï¼' },
            { name: 'å·¨çŸ³æ»¾è½', type: 'dmg', magnitude: 15, target: 'other', log: 'ğŸ—¿ å·¨çŸ³æ»¾è½ï¼å°æ‰‹é–ƒé¿ä¸åŠï¼Œé‡å‰µ {mag} é»ï¼' },
            { name: 'å¤§é›¨æ»‚æ²±', type: 'atk_debuff', magnitude: 0.7, duration: 1, target: 'all', element: 'FIRE', log: 'ğŸŒ§ï¸ å¤§é›¨æ»‚æ²±ï¼Œç«å±¬æ€§æ‹›å¼å¨åŠ›å¤§å¹…é™ä½ 30%ã€‚' },
            // Neutral/Mixed Events
            { name: 'é “æ‚Ÿè™›å¯¦', type: 'def_boost', magnitude: 5, duration: 1, target: 'self', log: 'â˜¯ï¸ é “æ‚Ÿè™›å¯¦ä¹‹é“ï¼Œé˜²ç¦¦æå‡ 5 é»ã€‚' },
            { name: 'ä»¥å¼±æ“Šå¼·', type: 'atk_boost', magnitude: 1.2, duration: 1, target: 'self', log: 'ğŸ’¡ é ˜æ‚Ÿä»¥å¼±æ“Šå¼·ä¹‹å¥§ç§˜ï¼Œæ”»æ“Šæå‡ 20%ã€‚' },
            { name: 'å¯’æ°£é€¼äºº', type: 'atk_debuff', magnitude: 0.8, duration: 1, target: 'self', element: 'WATER', log: 'ğŸ¥¶ å¯’æ°£é€¼äººï¼Œéæ°´å±¬æ€§æ‹›å¼å¨åŠ›ä¸‹é™ 20%ã€‚' },
            { name: 'çƒˆæ—¥ç•¶ç©º', type: 'def_debuff', magnitude: 5, duration: 1, target: 'all', log: 'â˜€ï¸ çƒˆæ—¥ç•¶ç©ºï¼Œé›™æ–¹é«”åŠ›å—æï¼Œé˜²ç¦¦çš†é™ä½ 5 é»ã€‚' },
            { name: 'éš”ç©ºé»ç©´', type: 'def_debuff', magnitude: 15, duration: 1, target: 'other', log: 'ğŸ¯ é ˜æ‚Ÿéš”ç©ºé»ç©´ï¼Œå°æ‰‹è¢«ç ´é˜²ï¼Œä¸‹ä¸€æ“Šé˜²ç¦¦é™ä½ {mag} é»ã€‚' },
            { name: 'ç ´é‡œæ²‰èˆŸ', type: 'atk_boost', magnitude: 2.0, duration: 1, target: 'self', min_hp: 30, log: 'ğŸ”¥ ç ´é‡œæ²‰èˆŸï¼Œç”Ÿå‘½å€¼ä½æ–¼ 30% æ™‚æ”»æ“ŠåŠ›ç¬é–“ç¿»å€ï¼' }
        ];
        
        // --- Helper Functions ---
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        function getRandomKeyByWeight(weights) {
            let total = 0;
            for (let key in weights) { total += weights[key]; }
            let rand = Math.random() * total;
            for (let key in weights) {
                if (rand < weights[key]) return key;
                rand -= weights[key];
            }
        }

        function getElementInfo(key) { return ELEMENTS[key]; }

        /**
         * ä¿®æ­£å¾Œçš„æ‹›å¼ç”Ÿæˆå™¨
         */
        function generateMove(sectKey) {
            const sect = SECTS.find(s => s.id === sectKey);
            const totalTicks = 20;

            const typeKey = getRandomKeyByWeight(sect.types);
            const type = MOVE_TYPES[typeKey];
            const numSteps = randomInt(type.stepsMin, type.stepsMax);
            
            let steps = [];
            let moveGenerated = false;
            
            for (let attempt = 0; attempt < 10; attempt++) { 
                steps = [];
                let breaks = [0, totalTicks]; 

                for (let i = 0; i < numSteps - 1; i++) {
                    breaks.push(randomInt(1, totalTicks - 1));
                }
                breaks.sort((a, b) => a - b);

                for (let i = 0; i < breaks.length - 1; i++) {
                    steps.push(breaks[i+1] - breaks[i]);
                }

                const isValid = steps.every(step => step >= 2 && step <= type.stepMaxVal);
                
                if (isValid) {
                    moveGenerated = true;
                    break;
                }
            }

            if (!moveGenerated) {
                steps = [5, 5, 5, 5].slice(0, numSteps);
                let currentSum = steps.reduce((a, b) => a + b, 0);
                if (currentSum !== 20) {
                    steps[steps.length - 1] += (20 - currentSum);
                }
            }
            
            const name = sect.skillPrefix[randomInt(0, sect.skillPrefix.length-1)] + 
                         SKILL_SUFFIXES[randomInt(0, SKILL_SUFFIXES.length-1)] + 
                         " (" + type.name + ")";

            let effectDesc;
            if (typeKey === 'DEFEND') {
                const defAmount = steps.length * 3;
                effectDesc = `æå‡ ${defAmount} é»é˜²ç¦¦ã€‚ (å›åˆçµæŸè§¸ç™¼)`;
            } else if (typeKey === 'BUFF') {
                effectDesc = 'æ¸…é™¤è‡ªèº« Debuff ä¸¦å›å¾©å°‘é‡ HPã€‚ (å›åˆçµæŸè§¸ç™¼)';
            } else {
                 effectDesc = 'å¨åŠ›å€¼åŸºæ–¼æ­¥é©Ÿé•·åº¦ (è¶Šé•·è¶Šå¼·)';
            }

            return {
                name: name,
                element: sect.element,
                steps: steps, 
                totalTicks: 20,
                sectName: sect.name,
                type: typeKey, 
                desc: type.desc,
                power: type.basePower,
                effect: effectDesc,
                damageReceived: 0 
            };
        }


        // --- Game Class ---
        class KungFuGame {
            constructor() {
                this.player = null;
                this.enemy = null;
                this.turn = 0;
                this.currentTick = 0;
                this.gameState = 'START';
                this.combatInterval = null;
                this.logEl = document.getElementById('battle-log');
            }

            init() {
                // Stop any previous combat interval
                if (this.combatInterval) clearInterval(this.combatInterval);
                
                document.getElementById('overlay-screen').classList.add('hidden');
                document.getElementById('game-over-screen').classList.add('hidden');
                
                // Random Sect Assignment
                let pSectIdx = randomInt(0, 4);
                let eSectIdx;
                do {
                    eSectIdx = randomInt(0, 4);
                } while (eSectIdx === pSectIdx);

                this.player = this.createFighter(SECTS[pSectIdx], 'player', 'å¤§ä¿ ');
                this.enemy = this.createFighter(SECTS[eSectIdx], 'enemy', 'é«˜æ‰‹');
                
                this.turn = 0;
                this.currentTick = 0;
                
                // --- FIX 1: Update Sect Name Display ---
                document.getElementById('player-sect').innerText = `é–€æ´¾: ${this.player.sect.name}`;
                document.getElementById('enemy-sect').innerText = `é–€æ´¾: ${this.enemy.sect.name}`;
                // --- END FIX 1 ---

                this.updateUIStats();
                this.logEl.innerHTML = '<div class="text-center text-gray-500 italic">--- æ­¦æ—é¢¨é›²éŒ„ ---</div>';
                this.log("ğŸš© æ­¦æ—å¤§æœƒé–‹å¹•ï¼æ°£æ°›è‚…æ®ºï¼Œæˆ°æ„é«˜æ˜‚ã€‚", 'info');
                this.log(`å¤§ä¿ æ‚¨å‡ºèº«ã€${this.player.sect.name}ã€‘ï¼Œå°‡é¢å°ã€${this.enemy.sect.name}ã€‘çš„å¼·å‹æŒ‘æˆ°ã€‚`, 'info');
                
                // Display Sect features
                document.getElementById('player-sect-feature').innerText = `é–€æ´¾ç‰¹æ€§: ${this.player.sect.feature}`;
                document.getElementById('enemy-sect-feature').innerText = `é–€æ´¾ç‰¹æ€§: ${this.enemy.sect.feature}`;

                this.startTurn();
            }

            createFighter(sect, type, name) {
                return {
                    name: name,
                    type: type,
                    sect: sect,
                    element: sect.element,
                    hp: 100,
                    maxHp: 100,
                    def: 0, 
                    currentMove: null,
                    statusEffects: [], 
                    moveAttacks: [], 
                    currentStepIndex: 0,
                    // New fields for event buffs
                    temp_mods: [], // {type: 'atk_boost', value: 1.5, duration: 1, element: 'FIRE'}
                };
            }

            updateUIStats() {
                // Update HP and Status for both fighters
                [this.player, this.enemy].forEach(fighter => {
                    const prefix = fighter.type;
                    
                    document.getElementById(`${prefix}-hp-bar`).style.width = `${(fighter.hp / fighter.maxHp) * 100}%`;
                    document.getElementById(`${prefix}-hp-text`).innerText = `${Math.floor(fighter.hp)}/100`;
                    
                    // Show temporary buffs/debuffs from events
                    const tempMods = fighter.temp_mods.map(m => {
                        let icon = 'âœ¨';
                        if (m.type.includes('debuff')) icon = 'ğŸ”»';
                        if (m.type.includes('boost')) icon = 'ğŸ”º';
                        return `<span class="text-yellow-300">[${icon}${m.name} ${m.duration}]</span>`;
                    });

                    const statusText = fighter.statusEffects.map(s => `<span class="${getElementInfo(fighter.element).textColor}">[${s.name} ${s.duration}]</span>`).join(' ');

                    document.getElementById(`${prefix}-status`).innerHTML = `é˜²ç¦¦: ${fighter.def} | ç‹€æ…‹: ${statusText} ${tempMods.join(' ')}`;

                    const elem = getElementInfo(fighter.element);
                    const badge = document.getElementById(`${prefix}-element-badge`);
                    badge.className = `absolute -top-2 -right-2 w-8 h-8 rounded-full flex items-center justify-center text-xs border border-white ${elem.color}`;
                    badge.innerText = elem.icon;
                });

                document.getElementById('turn-count').innerText = this.turn;
                document.getElementById('tick-count').innerText = this.currentTick;
            }

            log(msg, type = 'neutral') {
                const div = document.createElement('p');
                div.className = 'py-1';
                
                // --- 3. è±å¯Œæˆ°é¬¥è¨˜éŒ„ ---
                if (type === 'damage') div.className += ' text-red-400 font-bold border-l-4 border-red-700 px-2';
                else if (type === 'info') div.className += ' text-yellow-400 border-l-4 border-yellow-700 px-2';
                else if (type === 'clash') div.className += ' text-white bg-yellow-900/30 px-2 border-l-4 border-yellow-500';
                else if (type === 'buff') div.className += ' text-green-400 border-l-4 border-green-700 px-2';
                else if (type === 'event') div.className += ' text-orange-300 bg-orange-900/40 px-2 border-l-4 border-orange-500 font-semibold';
                else div.className += ' text-gray-400';
                // --- END 3. ---

                div.innerHTML = msg;
                this.logEl.appendChild(div);
                this.logEl.scrollTop = this.logEl.scrollHeight;
            }

            startTurn() {
                this.turn++;
                this.currentTick = 0;
                this.gameState = 'SELECTION';
                
                this.player.currentMove = { damageReceived: 0 }; 
                this.enemy.currentMove = { damageReceived: 0 }; 
                
                // Decay temporary buffs/debuffs
                this.decayTempMods(this.player);
                this.decayTempMods(this.enemy);

                this.applySectPreTurnEffects(this.player);
                this.applySectPreTurnEffects(this.enemy);

                this.updateUIStats();
                
                const moves = [];
                for(let i=0; i<4; i++) moves.push(generateMove(this.player.sect.id));

                this.renderMoveSelection(moves);
                
                document.getElementById('player-timeline').innerHTML = '';
                document.getElementById('enemy-timeline').innerHTML = '';
                document.getElementById('player-move-name').innerText = 'è«‹é¸æ“‡æ‹›å¼...';
                document.getElementById('player-move-type').innerText = 'æ‹›å¼é¡å‹: --';
                document.getElementById('enemy-move-name').innerText = 'å°æ‰‹æ­£åœ¨é‹æ°£...';
                document.getElementById('enemy-move-type').innerText = 'å°æ‰‹æ‹›å¼é¡å‹: --';
                document.getElementById('timeline-cursor').style.left = '0%';
            }

            decayTempMods(fighter) {
                // Decrease duration of all temporary modifiers
                fighter.temp_mods = fighter.temp_mods.map(mod => ({
                    ...mod,
                    duration: mod.duration - 1
                })).filter(mod => mod.duration > 0);
            }
            
            applySectPreTurnEffects(fighter) {
                // å°‘æ— (é‡‘å‰›ä¸å£): +3 temp def
                if (fighter.sect.id === 'shaolin') {
                    fighter.def += 3; 
                    this.log(`${fighter.name}é‹è½‰ã€é‡‘å‰›ä¸å£ã€‘ï¼Œç²å¾— 3 é»è‡¨æ™‚é˜²ç¦¦ã€‚`, 'buff');
                }
                
                // Apply Status Damage and Decay (like 'ç‡ƒç‡’')
                let statusMsg = '';
                fighter.statusEffects = fighter.statusEffects.filter(s => {
                    if (s.name === 'ç‡ƒç‡’') {
                        statusMsg += `ğŸ”¥ ${fighter.name}å—åˆ°ã€Œç‡ƒç‡’ã€ç¼ç‡’ï¼Œæå¤± ${s.dmg} é»ç”Ÿå‘½ï¼`;
                        fighter.hp -= s.dmg;
                        fighter.currentMove.damageReceived += s.dmg;
                    }
                    s.duration--;
                    return s.duration > 0;
                });
                if (statusMsg) this.log(statusMsg, 'damage');
            }

            renderMoveSelection(moves) {
                const container = document.getElementById('move-cards');
                container.innerHTML = '';
                document.getElementById('control-panel').classList.remove('opacity-50', 'pointer-events-none');

                moves.forEach(move => {
                    const btn = document.createElement('button');
                    const moveType = MOVE_TYPES[move.type];
                    const elem = getElementInfo(move.element);

                    btn.className = `bg-gray-800 wuxia-border p-2 md:p-3 rounded flex flex-col items-start text-left card-hover transition-all active:scale-95 ${moveType.style}`;
                    
                    let barHtml = `<div class="flex w-full h-2 mt-2 rounded overflow-hidden bg-gray-900 border border-black/20">`;
                    move.steps.forEach((step, idx) => {
                        const widthPct = (step / 20) * 100;
                        let colorClass = elem.color; 
                        if (move.type === 'DEFEND') colorClass = 'bg-blue-800'; 
                        if (move.type === 'BUFF') colorClass = 'bg-green-700';
                        barHtml += `<div style="width:${widthPct}%;" class="${colorClass} border-r border-black/20" title="è“„åŠ› ${step} å–®ä½"></div>`;
                    });
                    barHtml += `</div>`;

                    btn.innerHTML = `
                        <div class="flex justify-between w-full">
                            <span class="font-bold text-white text-sm md:text-base truncate">${move.name}</span>
                            <span class="text-xs font-mono text-gray-200">é¡å‹: ${moveType.name}</span>
                        </div>
                        <div class="text-xs text-gray-200 mt-1 flex items-center">
                            <span class="elem-icon ${elem.color} mr-2">${elem.icon}</span>
                            <span>ç‰¹æ€§: ${move.desc}</span>
                        </div>
                        <div class="text-[10px] text-gray-300 mt-1">æ•ˆæœ: ${move.effect}</div>
                        ${barHtml}
                        <div class="mt-1 text-[10px] text-gray-400">ç¯€å¥: ${move.steps.join('+')} (å…± ${move.steps.length} æ­¥)</div>
                    `;

                    btn.onclick = () => this.playerSelectMove(move);
                    btn.onmouseenter = () => this.previewTimeline(move, 'player');
                    
                    container.appendChild(btn);
                });
            }

            previewTimeline(move, who) {
                const container = document.getElementById(who + '-timeline');
                container.innerHTML = '';
                const elem = getElementInfo(move.element);
                const type = MOVE_TYPES[move.type];
                
                // Update Name/Type in Timeline
                document.getElementById(`${who}-move-name`).innerText = move.name;
                document.getElementById(`${who}-move-type`).innerText = `é¡å‹: ${type.name} / å±¬æ€§: ${elem.name} ${elem.icon}`;


                move.steps.forEach((step, idx) => {
                    const widthPct = (step / 20) * 100;
                    const div = document.createElement('div');
                    
                    let colorClass = elem.color; 
                    if (move.type === 'DEFEND') colorClass = 'bg-blue-800'; 
                    if (move.type === 'BUFF') colorClass = 'bg-green-700'; 

                    div.className = `${colorClass} h-full border-r border-black/50 flex items-center justify-center text-[10px] text-white/80 relative`;
                    div.style.width = `${widthPct}%`;
                    
                    if (move.type === 'ATTACK') {
                        const icon = document.createElement('div');
                        icon.className = 'absolute right-0 top-0 bottom-0 w-1 bg-white/70 shadow-[0_0_5px_rgba(255,255,255,0.8)]';
                        div.appendChild(icon);
                    }
                    div.title = `è“„åŠ› ${step} å–®ä½`;
                    
                    container.appendChild(div);
                });
            }

            playerSelectMove(playerMove) {
                this.gameState = 'COMBAT';
                this.player.currentMove = playerMove;
                this.player.currentMove.damageReceived = 0; 
                
                // Enemy AI: Simple Random, weighted towards player's weakness
                let eMove;
                const counterElement = getElementInfo(this.player.element).weakness;
                
                for (let i = 0; i < 5; i++) {
                    eMove = generateMove(this.enemy.sect.id);
                    if (eMove.element === counterElement && Math.random() < 0.7) { 
                        break;
                    }
                }

                this.enemy.currentMove = eMove;
                this.enemy.currentMove.damageReceived = 0; 

                // Lock UI
                document.getElementById('control-panel').classList.add('opacity-50', 'pointer-events-none');
                this.previewTimeline(this.enemy.currentMove, 'enemy');
                this.previewTimeline(this.player.currentMove, 'player'); 

                this.log(`<br>=== ç¬¬ ${this.turn} å›åˆï¼š${this.player.name}ä½¿å‡ºã€${playerMove.name}ã€‘ï¼Œ${this.enemy.name}ä»¥ã€${this.enemy.currentMove.name}ã€‘æ‡‰æˆ°ï¼ ===`, 'info');
                
                // Pre-calculate attack ticks
                this.player.moveAttacks = this.getAttackTicks(this.player.currentMove);
                this.enemy.moveAttacks = this.getAttackTicks(this.enemy.currentMove);
                this.player.currentStepIndex = 0;
                this.enemy.currentStepIndex = 0;

                this.runCombatPhase();
            }
            
            getAttackTicks(move) {
                if (move.type !== 'ATTACK') return []; 
                let t = 0;
                return move.steps.map(s => {
                    t += s;
                    return { tick: t, power: s }; 
                });
            }

            runCombatPhase() {
                this.currentTick = 0;
                const maxTicks = 20;
                const tickDuration = 200; 
                const eventChance = 0.15; // 15% chance per tick to trigger an event

                this.combatInterval = setInterval(() => {
                    this.currentTick++;
                    
                    const cursorPct = (this.currentTick / maxTicks) * 100;
                    document.getElementById('timeline-cursor').style.left = `${cursorPct}%`;
                    document.getElementById('tick-count').innerText = this.currentTick;
                    
                    // --- 2. éš¨æ©Ÿäº‹ä»¶è§¸ç™¼ ---
                    if (Math.random() < eventChance) {
                        this.triggerRandomEvent();
                    }
                    // --- END 2. ---
                    
                    // --- Resolve Actions ---
                    const pAttacks = this.player.moveAttacks.filter(a => a.tick === this.currentTick);
                    const eAttacks = this.enemy.moveAttacks.filter(a => a.tick === this.currentTick);

                    if (pAttacks.length > 0 && eAttacks.length > 0) {
                        this.resolveClash(pAttacks, eAttacks);
                    } else if (pAttacks.length > 0) {
                        this.resolveAttack(this.player, this.enemy, pAttacks[0]);
                    } else if (eAttacks.length > 0) {
                        this.resolveAttack(this.enemy, this.player, eAttacks[0]);
                    }
                    
                    // Resolve Effects on End of 20 ticks
                    if (this.currentTick >= maxTicks) {
                        this.resolveEndOfMove(this.player);
                        this.resolveEndOfMove(this.enemy);
                        
                        // Decay Sect temp defense (Shaolin's +3)
                        this.player.def = Math.max(0, this.player.def - 3);
                        this.enemy.def = Math.max(0, this.enemy.def - 3);

                        // Decay Defend move bonus
                        if (this.player.currentMove.type === 'DEFEND') this.player.def = Math.max(0, this.player.def - this.player.currentMove.steps.length * 3);
                        if (this.enemy.currentMove.type === 'DEFEND') this.enemy.def = Math.max(0, this.enemy.def - this.enemy.currentMove.steps.length * 3);
                        
                        clearInterval(this.combatInterval);
                        if (this.player.hp > 0 && this.enemy.hp > 0) {
                            setTimeout(() => this.startTurn(), 1000);
                        } else {
                            this.endGame();
                        }
                    }

                    this.updateUIStats();
                    if (this.player.hp <= 0 || this.enemy.hp <= 0) {
                        clearInterval(this.combatInterval);
                        this.endGame();
                    }
                }, tickDuration);
            }

            triggerRandomEvent() {
                const event = EVENTS[randomInt(0, EVENTS.length - 1)];
                const f1 = this.player;
                const f2 = this.enemy;
                let targets = [];

                if (event.min_hp && f1.hp / f1.maxHp * 100 > event.min_hp && f2.hp / f2.maxHp * 100 > event.min_hp) {
                    return; // Condition not met for specific event
                }

                // Determine target(s)
                if (event.target === 'all') {
                    targets = [f1, f2];
                } else if (event.target === 'self') {
                    // Randomly select one fighter
                    targets = [Math.random() < 0.5 ? f1 : f2];
                } else if (event.target === 'other') {
                    // Randomly select one fighter, target is the other
                    const primary = Math.random() < 0.5 ? f1 : f2;
                    targets = [primary === f1 ? f2 : f1];
                }

                // Apply event effects
                let logMessage = `ğŸš¨ ã€${event.name}ã€‘ç™¼å‹•ï¼` + event.log.replace('{mag}', event.magnitude);
                let hitTarget = false;

                targets.forEach(fighter => {
                    // Element check for environment events
                    if (event.element && fighter.element !== event.element && (event.type.includes('boost') || event.type.includes('debuff'))) {
                         // If event is element-specific and fighter is not that element, ignore stat mod (but allow damage/heal)
                        if (!event.type.includes('dmg') && !event.type.includes('heal')) return; 
                    }
                    
                    // Apply HP/Damage
                    if (event.type === 'heal') {
                        fighter.hp = Math.min(fighter.maxHp, fighter.hp + event.magnitude);
                        hitTarget = true;
                    } else if (event.type === 'dmg') {
                        const actualDmg = event.magnitude;
                        this.applyDamage(fighter, actualDmg);
                        hitTarget = true;
                    }
                    
                    // Apply temporary stat modifiers
                    if (event.type.includes('boost') || event.type.includes('debuff')) {
                        // Check for existing similar modifier (optional: replace or stack)
                        fighter.temp_mods.push({
                            name: event.name,
                            type: event.type,
                            value: event.magnitude,
                            duration: event.duration
                        });
                        hitTarget = true;
                    }
                });

                if (hitTarget) {
                     this.log(logMessage, 'event');
                     const gameContainer = document.getElementById('game-container');
                     gameContainer.classList.add('flash-event');
                     setTimeout(() => gameContainer.classList.remove('flash-event'), 500);
                     this.updateUIStats();
                }
            }


            applyDamage(target, damage) {
                target.hp = Math.max(0, target.hp - damage);
                target.currentMove.damageReceived += damage;
                this.updateUIStats();
            }

            resolveEndOfMove(fighter) {
                const move = fighter.currentMove;
                
                // æ­¦ç•¶ (å¤ªæ¥µåœ“è½‰): å›åˆæœªå—å‚·å®³ (damageReceived <= 0) å‰‡å›è¡€
                if (fighter.sect.id === 'wudang' && fighter.currentMove.damageReceived <= 0) {
                    const healAmount = 5;
                    fighter.hp = Math.min(fighter.maxHp, fighter.hp + healAmount);
                    this.log(`â˜¯ï¸ ã€å¤ªæ¥µåœ“è½‰ã€‘ç™¼å¨ï¼${fighter.name}æ¯«é«®ç„¡å‚·ï¼Œå›å¾©äº† ${healAmount} é»ç”Ÿå‘½ã€‚`, 'buff');
                }

                // BUFF move: clear Debuff and heal
                if (move.type === 'BUFF') {
                    const originalStatusCount = fighter.statusEffects.length;
                    fighter.statusEffects = fighter.statusEffects.filter(s => s.name !== 'ç‡ƒç‡’');
                    if (originalStatusCount > fighter.statusEffects.length) {
                        this.log(`âœ¨ ${fighter.name}çš„ã€${move.name}ã€‘å…§åŠŸé‹è½‰ï¼Œæ¸…é™¤æ‰€æœ‰ç•°å¸¸ Debuffï¼`, 'buff');
                    }
                    const healAmount = 10;
                    fighter.hp = Math.min(fighter.maxHp, fighter.hp + healAmount);
                    this.log(`ğŸŒ± ${fighter.name}çš„æ°£æ¯å¹³é †ï¼Œå›å¾© ${healAmount} é»æ°£åŠ›ã€‚`, 'buff');
                }
            }

            resolveClash(pAttacks, eAttacks) {
                this.animEffect('clash');
                const pAttack = pAttacks[0]; 
                const eAttack = eAttacks[0];

                const pPower = pAttack.power;
                const ePower = eAttack.power;

                const baseDmgP = this.calcDamage(pPower, this.player, this.enemy, true);
                const baseDmgE = this.calcDamage(ePower, this.enemy, this.player, true);
                
                const finalDmgP = Math.max(1, Math.floor(baseDmgE * 0.4)); 
                const finalDmgE = Math.max(1, Math.floor(baseDmgP * 0.4));
                
                this.applyDamage(this.player, finalDmgP);
                this.applyDamage(this.enemy, finalDmgE);

                // --- 3. è±å¯Œæˆ°é¬¥è¨˜éŒ„ - æ‹›å¼ç¢°æ’ ---
                this.log(`[T${this.currentTick}] ğŸ’¥ é›™æ–¹æ‹³å‹ã€${this.player.currentMove.name}ã€‘èˆ‡ã€${this.enemy.currentMove.name}ã€‘åœ¨ç©ºä¸­æ¿€çƒˆç›¸æ’ï¼å…§åŠ›åéœ‡ï¼Œ${this.player.name}å—æ ${finalDmgP}ï¼Œ${this.enemy.name}å—æ ${finalDmgE}ã€‚`, 'clash');
                // --- END 3. ---
            }

            resolveAttack(attacker, defender, attack) {
                if (attacker.currentMove.type !== 'ATTACK') return;

                const baseDmg = this.calcDamage(attack.power, attacker, defender, false);
                
                let totalDef = defender.def;
                
                // Get temporary defense boost from events
                defender.temp_mods.filter(m => m.type === 'def_boost' || m.type === 'def_debuff').forEach(m => {
                    if (m.type === 'def_boost') totalDef += m.value;
                    if (m.type === 'def_debuff') totalDef = Math.max(0, totalDef - m.value); // Debuff is reductive
                });
                
                let finalDmg = Math.max(0, baseDmg - totalDef);
                
                if (finalDmg > 0) {
                    this.animEffect(attacker.type === 'player' ? 'hit-enemy' : 'hit-player');
                    this.applyDamage(defender, finalDmg);
                    
                    // --- 3. è±å¯Œæˆ°é¬¥è¨˜éŒ„ - æ‹›å¼å‘½ä¸­ ---
                    const defenseBlocked = baseDmg - finalDmg;
                    const hitMessage = defenseBlocked > 0 ? `é˜²ç¦¦å·²æŠµéŠ· ${defenseBlocked} é»å‚·å®³ã€‚` : 'é˜²ç¦¦ç¬é–“è¢«æ“Šç©¿ï¼';
                    this.log(`[T${this.currentTick}] âš¡ï¸ ${attacker.name}æ‹›å¼çŒ›æ”»ï¼ç²¾æº–å‘½ä¸­ï¼Œé€ æˆã€${finalDmg}ã€‘é»å‚·å®³ã€‚(${hitMessage})`, 'damage');
                    // --- END 3. ---
                    
                    // å³¨åµ‹ (çƒˆç«ç‡åŸ) - Apply Debuff
                    if (attacker.sect.id === 'emei' && Math.random() < 0.2) { 
                        const isBurning = defender.statusEffects.some(s => s.name === 'ç‡ƒç‡’');
                        if (!isBurning) {
                            defender.statusEffects.push({ name: 'ç‡ƒç‡’', duration: 3, dmg: 5 });
                            this.log(`ğŸ”¥ çƒˆç«ç‡åŸï¼${defender.name}èº«ä¸­ã€Œç‡ƒç‡’ã€Debuff (æŒçºŒ 3 å›åˆ)ï¼`, 'damage');
                        }
                    }
                } else {
                    // --- 3. è±å¯Œæˆ°é¬¥è¨˜éŒ„ - æ‹›å¼è¢«åŒ–è§£ ---
                    this.log(`[T${this.currentTick}] ğŸŒ¬ï¸ ${defender.name}ã€${defender.currentMove.name}ã€‘å®ˆå¼ç²¾å¦™ï¼Œå°‡æ”»å‹¢å®Œå…¨åŒ–è§£ï¼æ»´æ°´ä¸æ¼ã€‚`, 'buff');
                    // --- END 3. ---
                }
            }

            calcDamage(stepPower, attacker, defender, isClash) {
                let dmg = stepPower * attacker.currentMove.power;
                let attackModifier = 1.0;
                
                // Get temporary attack boost from events
                attacker.temp_mods.filter(m => m.type === 'atk_boost' || m.type === 'atk_debuff').forEach(m => {
                    // Element filter
                    if (m.element && attacker.element !== m.element) return;

                    if (m.type === 'atk_boost') attackModifier *= m.value;
                    if (m.type === 'atk_debuff') attackModifier *= m.value;
                });
                
                dmg *= attackModifier; // Apply temp mods

                // 1. Element Check (Only on ATTACK moves)
                if (attacker.currentMove.type === 'ATTACK') {
                    const attEl = getElementInfo(attacker.element);
                    
                    if (attEl.beats === defender.element) {
                        dmg *= 1.3; 
                        if (!isClash) this.log(`[T${this.currentTick}] âš”ï¸ äº”è¡Œç›¸å‰‹ ( ${attEl.name} > ${getElementInfo(defender.element).name} )ï¼Œå¨åŠ›æ¿€å¢ 30%ï¼`, 'info');
                    } else if (attEl.weakness === defender.element) {
                        dmg *= 0.8; 
                    }
                }

                // 2. Sect Bonuses
                // è¯å±± (åŠèµ°åé‹’): 30% crit on fast hits (stepPower 3-5)
                if (attacker.sect.id === 'huashan' && stepPower >= 3 && stepPower <= 5 && Math.random() < 0.3) {
                    dmg *= 1.5; 
                    if (!isClash) this.log(`[T${this.currentTick}] âš¡ï¸ ${attacker.name}ã€åŠèµ°åé‹’ã€‘ç™¼å‹•ï¼æ‹›å¼è¼•éˆï¼Œé€ æˆè‡´å‘½çˆ†æ“Šï¼`, 'damage');
                }

                // ä¸å¹« (åŒ–éšªç‚ºå¤·): Power boost below 30% HP
                if (attacker.sect.id === 'beggar' && attacker.hp / attacker.maxHp <= 0.3) {
                    dmg *= 1.25;
                    if (!isClash) this.log(`[T${this.currentTick}] ğŸ’ª ${attacker.name}ã€åŒ–éšªç‚ºå¤·ã€‘ç™¼å‹•ï¼æµ´è¡€å¥®æˆ°ï¼Œå¨åŠ›å¤§å¢ï¼`, 'damage');
                }

                return Math.floor(dmg);
            }

            animEffect(type) {
                const gameContainer = document.getElementById('game-container');
                
                if (type === 'hit-enemy') {
                    document.getElementById('enemy-avatar').classList.add('shake', 'flash-hit');
                    setTimeout(() => document.getElementById('enemy-avatar').classList.remove('shake', 'flash-hit'), 500);
                    this.showFloatingText("ğŸ‘ŠğŸ’¥", "right");
                } else if (type === 'hit-player') {
                    document.getElementById('player-avatar').classList.add('shake', 'flash-hit');
                    setTimeout(() => document.getElementById('player-avatar').classList.remove('shake', 'flash-hit'), 500);
                    this.showFloatingText("ğŸ‘ŠğŸ’¥", "left");
                } else if (type === 'clash') {
                    gameContainer.classList.add('flash-clash');
                    setTimeout(() => gameContainer.classList.remove('flash-clash'), 300);
                    this.showFloatingText("âš”ï¸", "center");
                }
            }

            showFloatingText(text, pos) {
                const el = document.createElement('div');
                el.innerText = text;
                el.className = "absolute text-4xl animate-bounce transition-opacity duration-1000 pointer-events-none opacity-100 font-extrabold";
                el.style.top = "40%";
                el.style.transform = "translate(-50%, -50%)"; 
                
                if(pos === 'left') el.style.left = "20%";
                else if(pos === 'right') el.style.left = "80%";
                else el.style.left = "50%";
                
                document.getElementById('battle-anim-layer').appendChild(el);
                
                setTimeout(() => el.classList.remove('opacity-100'), 100);
                setTimeout(() => el.remove(), 1000);
            }

            endGame() {
                const screen = document.getElementById('game-over-screen');
                const title = document.getElementById('end-title');
                const reason = document.getElementById('end-reason');
                screen.classList.remove('hidden');
                
                if (this.combatInterval) clearInterval(this.combatInterval);

                if (this.player.hp <= 0 && this.enemy.hp <= 0) {
                    title.innerText = "å…©æ•—ä¿±å‚·";
                    title.className = "text-5xl text-gray-400 mb-4 font-bold";
                    reason.innerText = "é›™æ–¹å…§åŠ›è€—ç›¡ï¼ŒåŒæ­¸æ–¼ç›¡ï¼é€™æ˜¯ä¸€å ´æ²’æœ‰è´å®¶çš„æ…˜çƒˆä¹‹æˆ°ã€‚";
                } else if (this.player.hp > 0) {
                    title.innerText = "æ­å–œå‹å‡º";
                    title.className = "text-5xl text-yellow-500 mb-4 font-bold";
                    reason.innerText = `å¤§ä¿ ä»¥${this.player.sect.name}çµ•å­¸çš„ã€${this.player.currentMove.name}ã€‘çµ•æ®ºï¼Œæ“Šæ•—äº†${this.enemy.sect.name}çš„é«˜æ‰‹ï¼æšåç«‹è¬ï¼`;
                } else {
                    title.innerText = "éºæ†¾æ•—åŒ—";
                    title.className = "text-5xl text-red-600 mb-4 font-bold";
                    reason.innerText = `å¤§ä¿ é›–ç«­åŠ›æ‡‰æˆ°ï¼Œä½†æœ€çµ‚ä»æƒœæ•—æ–¼${this.enemy.sect.name}çš„ã€${this.enemy.currentMove.name}ã€‘ã€‚è‹¦ç·´å…§åŠŸï¼Œæ±å±±å†èµ·ï¼`;
                }
            }
        }

        // Start Game Instance
        const game = new KungFuGame();

    </script>
</body>
</html>